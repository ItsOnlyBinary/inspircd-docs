diff --git a/README.md b/README.md
index 553d41332..7cabb879c 100644
--- a/README.md
+++ b/README.md
@@ -39,6 +39,6 @@ InspIRCd is licensed under [version 2 of the GNU General Public License](https:/
 * [Website](https://www.inspircd.org)
 * [Documentation](https://docs.inspircd.org)
 * [GitHub](https://github.com/inspircd)
-* [Support IRC channel](https://kiwiirc.com/nextclient/irc.inspircd.org:+6697/inspircd?nick=Your%20nick%20here) &mdash; \#inspircd on irc.inspircd.org
-* [Development IRC channel](https://kiwiirc.com/nextclient/irc.inspircd.org:+6697/inspircd.dev?nick=Your%20nick%20here) &mdash; \#inspircd.dev on irc.inspircd.org
-* [InspIRCd test network](https://kiwiirc.com/nextclient/testnet.inspircd.org:+6697/?nick=Your%20nick%20here) &mdash; testnet.inspircd.org
+* Support IRC channel &mdash; \#inspircd on irc.inspircd.org
+* Development IRC channel &mdash; \#inspircd.dev on irc.inspircd.org
+* InspIRCd test network &mdash; testnet.inspircd.org
diff --git a/configure b/configure
index 4ff0fa915..83c11b5d2 100755
--- a/configure
+++ b/configure
@@ -211,7 +211,7 @@ if (defined $opt_portable) {
 	$config{LOG_DIR}     = $opt_log_dir     // catdir $config{BASE_DIR}, 'var/log/inspircd';
 	$config{MANUAL_DIR}  = $opt_manual_dir  // catdir $config{BASE_DIR}, 'usr/share/man/man1';
 	$config{MODULE_DIR}  = $opt_module_dir  // catdir $config{BASE_DIR}, 'usr/lib/inspircd';
-	$config{RUNTIME_DIR} = $opt_runtime_dir // catdir $config{BASE_DIR}, 'var/run';
+	$config{RUNTIME_DIR} = $opt_runtime_dir // catdir $config{BASE_DIR}, 'var/run/inspircd';
 	$config{SCRIPT_DIR}  = $opt_script_dir  // catdir $config{BASE_DIR}, 'usr/share/inspircd';
 } else {
 	$config{BASE_DIR}    = rel2abs $opt_prefix // $config{BASE_DIR}    // catdir $RealDir,            'run';
diff --git a/docs/conf/modules.conf.example b/docs/conf/modules.conf.example
index 4be14c960..6eb61cc38 100644
--- a/docs/conf/modules.conf.example
+++ b/docs/conf/modules.conf.example
@@ -1766,7 +1766,7 @@
 #<permchanneldb filename="permchannels.conf"
 #               listmodes="yes"
 #               saveperiod="5s">
-#<include file="permchannels.conf">
+#<include file="permchannels.conf" missingokay="yes">
 #
 # You may also create channels on startup by using the <permchannels> block.
 #<permchannels channel="#opers" modes="isP" topic="Opers only.">
diff --git a/docs/conf/providers/torexit.conf.example b/docs/conf/providers/torexit.conf.example
index e9e62c43a..abc35c696 100644
--- a/docs/conf/providers/torexit.conf.example
+++ b/docs/conf/providers/torexit.conf.example
@@ -6,6 +6,7 @@
        domain="torexit.dan.me.uk"
        type="record"
        records="100"
+       timeout="10s"
        action="zline"
        duration="7d"
        reason="Tor exit nodes are not allowed on this network. See https://metrics.torproject.org/rs.html#search/%ip% for more information.">
diff --git a/include/channels.h b/include/channels.h
index 1b44a7be6..0b38958cc 100644
--- a/include/channels.h
+++ b/include/channels.h
@@ -165,7 +165,6 @@ class CoreExport Channel : public Extensible
 
 	/** Delete a user pointer to the internal reference list
 	 * @param user The user to delete
-	 * @return number of users left on the channel after deletion of the user
 	 */
 	void DelUser(User* user);
 
diff --git a/include/inspircd.h b/include/inspircd.h
index a55d52c0b..b0e9903f2 100644
--- a/include/inspircd.h
+++ b/include/inspircd.h
@@ -538,7 +538,6 @@ class CoreExport InspIRCd
 	/** Attempt to write the process id to a given file
 	 * @param filename The PID file to attempt to write to
 	 * @param exitonfail If true and the PID fail cannot be written log to stdout and exit, otherwise only log on failure
-	 * @return This function may bail if the file cannot be written
 	 */
 	void WritePID(const std::string& filename, bool exitonfail = true);
 
diff --git a/include/mode.h b/include/mode.h
index 17f7e0133..82dd75770 100644
--- a/include/mode.h
+++ b/include/mode.h
@@ -681,7 +681,7 @@ class CoreExport ModeParser : public fakederef<ModeParser>
 	 *
 	 * host.name -> *!*\@host.name
 	 *
-	 * ident@host.name -> *!ident\@host.name
+	 * ident\@host.name -> *!ident\@host.name
 	 *
 	 * This method can be used on both IPV4 and IPV6 user masks.
 	 */
diff --git a/include/modules/away.h b/include/modules/away.h
index e70b598cf..563b599fe 100644
--- a/include/modules/away.h
+++ b/include/modules/away.h
@@ -51,7 +51,6 @@ class Away::EventListener
 
 	/** Called when a user wishes to mark themselves as back.
 	 * @param user The user who is going away.
-	 * @param message The away message that the user set.
 	 * @return Either MOD_RES_ALLOW to allow the user to mark themself as back, MOD_RES_DENY to
 	 *         disallow the user to mark themself as back, or MOD_RES_PASSTHRU to let another module
 	 *         handle the event.
diff --git a/include/modules/dns.h b/include/modules/dns.h
index 141951fd3..bce842bd8 100644
--- a/include/modules/dns.h
+++ b/include/modules/dns.h
@@ -166,8 +166,8 @@ namespace DNS
 	 	/* Creator of this request */
 		Module* const creator;
 
-		Request(Manager* mgr, Module* mod, const std::string& addr, QueryType qt, bool usecache = true)
-			: Timer(ServerInstance->Config->ConfValue("dns")->getDuration("timeout", 5, 1))
+		Request(Manager* mgr, Module* mod, const std::string& addr, QueryType qt, bool usecache = true, unsigned int timeout = 0)
+			: Timer(timeout ? timeout : ServerInstance->Config->ConfValue("dns")->getDuration("timeout", 5, 1))
 			, manager(mgr)
 			, question(addr, qt)
 			, use_cache(usecache)
@@ -182,12 +182,12 @@ namespace DNS
 		}
 
 		/** Called when this request succeeds
-		 * @param r The query sent back from the nameserver
+		 * @param req The query sent back from the nameserver
 		 */
 		virtual void OnLookupComplete(const Query* req) = 0;
 
 		/** Called when this request fails or times out.
-		 * @param r The query sent back from the nameserver, check the error code.
+		 * @param req The query sent back from the nameserver, check the error code.
 		 */
 		virtual void OnError(const Query* req) { }
 
diff --git a/include/modules/httpd.h b/include/modules/httpd.h
index dca35f099..ccb71595c 100644
--- a/include/modules/httpd.h
+++ b/include/modules/httpd.h
@@ -186,17 +186,18 @@ class HTTPRequest
 	/** Initialize HTTPRequest.
 	 * This constructor is called by m_httpd.so to initialize the class.
 	 * @param request_type The request type, e.g. GET, POST, HEAD
+	 * @param parsed_uri The URI which was requested by the client.
 	 * @param hdr The headers sent with the request
-	 * @param opaque An opaque pointer used internally by m_httpd, which you must pass back to the module in your reply.
+	 * @param socket The server socket which this request came in via.
 	 * @param ip The IP address making the web request.
 	 * @param pdata The post data (content after headers) received with the request, up to Content-Length in size
 	 */
-	HTTPRequest(const std::string& request_type, const HTTPRequestURI& Parseduri,
-		HTTPHeaders* hdr, HttpServerSocket* socket, const std::string &ip, const std::string &pdata)
+	HTTPRequest(const std::string& request_type, const HTTPRequestURI& parsed_uri, HTTPHeaders* hdr,
+			HttpServerSocket* socket, const std::string& ip, const std::string& pdata)
 		: type(request_type)
 		, ipaddr(ip)
 		, postdata(pdata)
-		, parseduri(Parseduri)
+		, parseduri(parsed_uri)
 		, headers(hdr)
 		, sock(socket)
 	{
diff --git a/include/modules/sql.h b/include/modules/sql.h
index 47da6f6bf..292322cda 100644
--- a/include/modules/sql.h
+++ b/include/modules/sql.h
@@ -129,9 +129,9 @@ class SQL::Result : public classbase
 	/**
 	 * Check if there's a column with the specified name in the result
 	 *
-	 * @param the column name
-	 * @param on success, this is the column index
-	 * @returns true, or false if the column is not found
+	 * @param column The column name.
+	 * @param index The place to store the column index if it exists.
+	 * @returns If the column exists then true; otherwise, false.
 	 */
 	virtual bool HasColumn(const std::string& column, size_t& index) = 0;
 };
diff --git a/include/socketengine.h b/include/socketengine.h
index 26d31c168..d8d5e406d 100644
--- a/include/socketengine.h
+++ b/include/socketengine.h
@@ -326,8 +326,6 @@ public:
 	 * failure (for example, you try and enable
 	 * epoll on a 2.4 linux kernel) then this
 	 * function may bail back to the shell.
-	 * @return void, but it is acceptable for this function to bail back to
-	 * the shell or operating system on fatal error.
 	 */
 	static void Init();
 
@@ -556,8 +554,6 @@ public:
 	 * allows for the socket engine to re-create its handle
 	 * after the daemon forks as the socket engine is created
 	 * long BEFORE the daemon forks.
-	 * @return void, but it is acceptable for this function to bail back to
-	 * the shell or operating system on fatal error.
 	 */
 	static void RecoverFromFork();
 
diff --git a/include/stdalgo.h b/include/stdalgo.h
index c0baa9dd8..585114fce 100644
--- a/include/stdalgo.h
+++ b/include/stdalgo.h
@@ -28,10 +28,10 @@ namespace stdalgo
 		 * Erase a single element from a vector by overwriting it with a copy of the last element,
 		 * which is then removed. This, in contrast to vector::erase(), does not result in all
 		 * elements after the erased element being moved.
+		 * Returns nothing, but all iterators, references and pointers to the erased element and the
+		 * last element are invalidated
 		 * @param vect Vector to remove the element from
 		 * @param it Iterator to the element to remove
-		 * @return Nothing, but all iterators, references and pointers to the erased element and the
-		 * last element are invalidated
 		 */
 		template <typename T>
 		inline void swaperase(typename std::vector<T>& vect, const typename std::vector<T>::iterator& it)
diff --git a/include/users.h b/include/users.h
index b9092b678..8045d5705 100644
--- a/include/users.h
+++ b/include/users.h
@@ -91,10 +91,12 @@ struct CoreExport ConnectClass : public refcountbase
 	 */
 	unsigned int registration_timeout;
 
-	/** Host mask for this line
-	 */
+	/** Hosts that this user can connect from as a string. */
 	std::string host;
 
+	/** Hosts that this user can connect from as a vector. */
+	std::vector<std::string> hosts;
+
 	/** Number of seconds between pings for this line
 	 */
 	unsigned int pingtime;
@@ -166,8 +168,9 @@ struct CoreExport ConnectClass : public refcountbase
 	/** Update the settings in this block to match the given block */
 	void Update(const ConnectClass* newSettings);
 
-	const std::string& GetName() { return name; }
-	const std::string& GetHost() { return host; }
+	const std::string& GetName() const { return name; }
+	const std::string& GetHost() const { return host; }
+	const std::vector<std::string>& GetHosts() const { return hosts; }
 
 	/** Returns the registration timeout
 	 */
@@ -240,19 +243,19 @@ struct CoreExport ConnectClass : public refcountbase
 class CoreExport User : public Extensible
 {
  private:
-	/** Cached nick!ident@dhost value using the displayed hostname
+	/** Cached nick!ident\@dhost value using the displayed hostname
 	 */
 	std::string cached_fullhost;
 
-	/** Cached ident@ip value using the real IP address
+	/** Cached ident\@ip value using the real IP address
 	 */
 	std::string cached_hostip;
 
-	/** Cached ident@realhost value using the real hostname
+	/** Cached ident\@realhost value using the real hostname
 	 */
 	std::string cached_makehost;
 
-	/** Cached nick!ident@realhost value using the real hostname
+	/** Cached nick!ident\@realhost value using the real hostname
 	 */
 	std::string cached_fullrealhost;
 
@@ -847,7 +850,6 @@ class CoreExport LocalUser : public User, public insp::intrusive_list_node<Local
 
 	/** Set the connect class to which this user belongs to.
 	 * @param explicit_name Set this string to tie the user to a specific class name. Otherwise, the class is fitted by checking \<connect> tags from the configuration file.
-	 * @return A reference to this user's current connect class.
 	 */
 	void SetClass(const std::string &explicit_name = "");
 
diff --git a/src/configparser.cpp b/src/configparser.cpp
index 556442627..9f5a49f1d 100644
--- a/src/configparser.cpp
+++ b/src/configparser.cpp
@@ -39,7 +39,10 @@ enum ParseFlags
 	FLAG_NO_INC = 4,
 
 	// &env.FOO; is disabled.
-	FLAG_NO_ENV = 8
+	FLAG_NO_ENV = 8,
+
+	// It's okay if an include doesn't exist.
+	FLAG_MISSING_OKAY = 16
 };
 
 // Represents the position within a config file.
@@ -420,11 +423,18 @@ void ParseStack::DoInclude(ConfigTag* tag, int flags)
 	{
 		if (tag->getBool("noinclude", false))
 			flags |= FLAG_NO_INC;
+
 		if (tag->getBool("noexec", false))
 			flags |= FLAG_NO_EXEC;
+
 		if (tag->getBool("noenv", false))
 			flags |= FLAG_NO_ENV;
 
+		if (tag->getBool("missingokay", false))
+			flags |= FLAG_MISSING_OKAY;
+		else
+			flags &= ~FLAG_MISSING_OKAY;
+
 		if (!ParseFile(ServerInstance->Config->Paths.PrependConfig(name), flags, mandatorytag))
 			throw CoreException("Included");
 	}
@@ -504,7 +514,12 @@ bool ParseStack::ParseFile(const std::string& path, int flags, const std::string
 
 	FileWrapper file((isexec ? popen(path.c_str(), "r") : fopen(path.c_str(), "r")), isexec);
 	if (!file)
+	{
+		if (flags & FLAG_MISSING_OKAY)
+			return true;
+
 		throw CoreException("Could not read \"" + path + "\" for include");
+	}
 
 	reading.push_back(path);
 	Parser p(*this, flags, file, path, mandatory_tag);
diff --git a/src/configreader.cpp b/src/configreader.cpp
index 2cd17e844..381d28d1b 100644
--- a/src/configreader.cpp
+++ b/src/configreader.cpp
@@ -242,9 +242,9 @@ void ServerConfig::CrossCheckConnectBlocks(ServerConfig* current)
 			std::string mask;
 			char type;
 
-			if (tag->readString("allow", mask, false))
+			if (tag->readString("allow", mask, false) && !mask.empty())
 				type = CC_ALLOW;
-			else if (tag->readString("deny", mask, false))
+			else if (tag->readString("deny", mask, false) && !mask.empty())
 				type = CC_DENY;
 			else if (!name.empty())
 			{
diff --git a/src/coremods/core_reloadmodule.cpp b/src/coremods/core_reloadmodule.cpp
index 6836cb55c..ef0b13962 100644
--- a/src/coremods/core_reloadmodule.cpp
+++ b/src/coremods/core_reloadmodule.cpp
@@ -284,7 +284,7 @@ class DataKeeper
 
 	/** Restore all modes and extensions of all members on a channel
 	 * @param chan Channel whose members are being restored
-	 * @param memberdata Data to restore
+	 * @param memberdatalist Data to restore
 	 * @param modechange Mode change to populate with prefix modes
 	 */
 	void RestoreMemberData(Channel* chan, const std::vector<ChanData::MemberData>& memberdatalist, Modes::ChangeList& modechange);
diff --git a/src/coremods/core_stats.cpp b/src/coremods/core_stats.cpp
index 19e429a95..6ce733db7 100644
--- a/src/coremods/core_stats.cpp
+++ b/src/coremods/core_stats.cpp
@@ -196,8 +196,9 @@ void CommandStats::DoStats(Stats::Context& stats)
 				if (!oper->server->IsULine())
 				{
 					LocalUser* lu = IS_LOCAL(oper);
-					stats.AddRow(249, oper->nick + " (" + oper->ident + "@" + oper->GetDisplayedHost() + ") Idle: " +
-							(lu ? ConvToStr(ServerInstance->Time() - lu->idle_lastmsg) + " secs" : "unavailable"));
+					const std::string idle = lu ? InspIRCd::DurationString(ServerInstance->Time() - lu->idle_lastmsg) : "unavailable";
+					stats.AddRow(249, InspIRCd::Format("%s (%s@%s) Idle: %s", oper->nick.c_str(),
+						oper->ident.c_str(), oper->GetDisplayedHost().c_str(), idle.c_str()));
 					idx++;
 				}
 			}
diff --git a/src/modules/extra/m_ssl_gnutls.cpp b/src/modules/extra/m_ssl_gnutls.cpp
index 4e6b09564..5dadda184 100644
--- a/src/modules/extra/m_ssl_gnutls.cpp
+++ b/src/modules/extra/m_ssl_gnutls.cpp
@@ -1314,7 +1314,7 @@ class ModuleSSLGnuTLS : public Module
 		}
 		else
 		{
-			ServerInstance->Logs->Log(MODNAME, LOG_DEFAULT, "You have defined an <sslprofile> tag; you should use this in place of \"gnutls\" when configuring TLS (SSL) connections in <bind:ssl> or <link:ssl>");
+			ServerInstance->Logs->Log(MODNAME, LOG_DEFAULT, "You have defined an <sslprofile> tag; you should use this in place of \"gnutls\" when configuring TLS (SSL) connections in <bind:sslprofile> or <link:sslprofile>");
 			for (ConfigIter i = tags.first; i != tags.second; ++i)
 			{
 				ConfigTag* tag = i->second;
diff --git a/src/modules/extra/m_ssl_mbedtls.cpp b/src/modules/extra/m_ssl_mbedtls.cpp
index 77c81b7fa..5c768ce3c 100644
--- a/src/modules/extra/m_ssl_mbedtls.cpp
+++ b/src/modules/extra/m_ssl_mbedtls.cpp
@@ -888,7 +888,7 @@ class ModuleSSLmbedTLS : public Module
 		}
 		else
 		{
-			ServerInstance->Logs->Log(MODNAME, LOG_DEFAULT, "You have defined an <sslprofile> tag; you should use this in place of \"mbedtls\" when configuring TLS (SSL) connections in <bind:ssl> or <link:ssl>");
+			ServerInstance->Logs->Log(MODNAME, LOG_DEFAULT, "You have defined an <sslprofile> tag; you should use this in place of \"mbedtls\" when configuring TLS (SSL) connections in <bind:sslprofile> or <link:sslprofile>");
 			for (ConfigIter i = tags.first; i != tags.second; ++i)
 			{
 				ConfigTag* tag = i->second;
diff --git a/src/modules/extra/m_ssl_openssl.cpp b/src/modules/extra/m_ssl_openssl.cpp
index fb965a5ab..0f4e2d713 100644
--- a/src/modules/extra/m_ssl_openssl.cpp
+++ b/src/modules/extra/m_ssl_openssl.cpp
@@ -1000,7 +1000,7 @@ class ModuleSSLOpenSSL : public Module
 		}
 		else
 		{
-			ServerInstance->Logs->Log(MODNAME, LOG_DEFAULT, "You have defined an <sslprofile> tag; you should use this in place of \"openssl\" when configuring TLS (SSL) connections in <bind:ssl> or <link:ssl>");
+			ServerInstance->Logs->Log(MODNAME, LOG_DEFAULT, "You have defined an <sslprofile> tag; you should use this in place of \"openssl\" when configuring TLS (SSL) connections in <bind:sslprofile> or <link:sslprofile>");
 			for (ConfigIter i = tags.first; i != tags.second; ++i)
 			{
 				ConfigTag* tag = i->second;
diff --git a/src/modules/m_blockcolor.cpp b/src/modules/m_blockcolor.cpp
index c5dc35fe3..905cc50b5 100644
--- a/src/modules/m_blockcolor.cpp
+++ b/src/modules/m_blockcolor.cpp
@@ -60,10 +60,15 @@ class ModuleBlockColor : public Module
 			bool modeset = c->IsModeSet(bc);
 			if (!c->GetExtBanStatus(user, 'c').check(!modeset))
 			{
-				for (std::string::iterator i = details.text.begin(); i != details.text.end(); i++)
+				std::string ctcpname; // Unused.
+				std::string message;
+				if (!details.IsCTCP(ctcpname, message))
+					message.assign(details.text);
+
+				for (std::string::iterator i = message.begin(); i != message.end(); ++i)
 				{
-					// Block all control codes except \001 for CTCP
-					if ((*i >= 0) && (*i < 32) && (*i != 1))
+					const unsigned char chr = static_cast<unsigned char>(*i);
+					if (chr < 32)
 					{
 						if (modeset)
 							user->WriteNumeric(Numerics::CannotSendTo(c, "messages containing formatting characters", &bc));
diff --git a/src/modules/m_censor.cpp b/src/modules/m_censor.cpp
index bd63809ed..b78364b0b 100644
--- a/src/modules/m_censor.cpp
+++ b/src/modules/m_censor.cpp
@@ -28,12 +28,12 @@
 #include "inspircd.h"
 #include "modules/exemption.h"
 
-typedef insp::flat_map<std::string, std::string, irc::insensitive_swo> censor_t;
+typedef insp::flat_map<std::string, std::string, irc::insensitive_swo> CensorMap;
 
 class ModuleCensor : public Module
 {
 	CheckExemption::EventProvider exemptionprov;
-	censor_t censors;
+	CensorMap censors;
 	SimpleUserModeHandler cu;
 	SimpleChannelModeHandler cc;
 
@@ -77,7 +77,7 @@ class ModuleCensor : public Module
 				return MOD_RES_PASSTHRU;
 		}
 
-		for (censor_t::iterator index = censors.begin(); index != censors.end(); index++)
+		for (CensorMap::const_iterator index = censors.begin(); index != censors.end(); ++index)
 		{
 			size_t censorpos;
 			while ((censorpos = irc::find(details.text, index->first)) != std::string::npos)
@@ -104,8 +104,7 @@ class ModuleCensor : public Module
 		 * reload our config file on rehash - we must destroy and re-allocate the classes
 		 * to call the constructor again and re-read our data.
 		 */
-		censor_t newcensors;
-
+		CensorMap newcensors;
 		ConfigTagList badwords = ServerInstance->Config->ConfTags("badword");
 		for (ConfigIter i = badwords.first; i != badwords.second; ++i)
 		{
diff --git a/src/modules/m_cgiirc.cpp b/src/modules/m_cgiirc.cpp
index 9ad25e6fb..f0963e4c1 100644
--- a/src/modules/m_cgiirc.cpp
+++ b/src/modules/m_cgiirc.cpp
@@ -332,6 +332,26 @@ class ModuleCgiIRC
 		ServerInstance->SNO->EnableSnomask('w', "CGIIRC");
 	}
 
+	void On005Numeric(std::map<std::string, std::string>& tokens) CXX11_OVERRIDE
+	{
+		tokens["EXTBAN"].push_back('w');
+	}
+
+	ModResult OnCheckBan(User* user, Channel*, const std::string& mask) CXX11_OVERRIDE
+	{
+		if (mask.length() <= 2 || mask[0] != 'w' || mask[1] != ':')
+			return MOD_RES_PASSTHRU;
+
+		const std::string* gateway = cmdwebirc.gateway.get(user);
+		if (!gateway)
+			return MOD_RES_PASSTHRU;
+
+		if (InspIRCd::Match(*gateway, mask.substr(2)))
+			return MOD_RES_DENY;
+
+		return MOD_RES_PASSTHRU;
+	}
+
 	void ReadConfig(ConfigStatus& status) CXX11_OVERRIDE
 	{
 		std::vector<IdentHost> identhosts;
@@ -516,15 +536,17 @@ class ModuleCgiIRC
 
 	void OnWhois(Whois::Context& whois) CXX11_OVERRIDE
 	{
-		if (!whois.IsSelfWhois() && !whois.GetSource()->HasPrivPermission("users/auspex"))
-			return;
-
 		// If these fields are not set then the client is not using a gateway.
-		const std::string* realhost = cmdwebirc.realhost.get(whois.GetTarget());
-		const std::string* realip = cmdwebirc.realip.get(whois.GetTarget());
+		std::string* realhost = cmdwebirc.realhost.get(whois.GetTarget());
+		std::string* realip = cmdwebirc.realip.get(whois.GetTarget());
 		if (!realhost || !realip)
 			return;
 
+		// If the source doesn't have the right privs then only show the gateway name.
+		std::string hidden = "*";
+		if (!whois.GetSource()->HasPrivPermission("users/auspex"))
+			realhost = realip = &hidden;
+
 		const std::string* gateway = cmdwebirc.gateway.get(whois.GetTarget());
 		if (gateway)
 			whois.SendLine(RPL_WHOISGATEWAY, *realhost, *realip, "is connected via the " + *gateway + " WebIRC gateway");
diff --git a/src/modules/m_chanhistory.cpp b/src/modules/m_chanhistory.cpp
index 38ec217df..3ad6b81e6 100644
--- a/src/modules/m_chanhistory.cpp
+++ b/src/modules/m_chanhistory.cpp
@@ -61,6 +61,18 @@ struct HistoryList
 		, maxtime(time)
 	{
 	}
+
+	size_t Prune()
+	{
+		// Prune expired entries from the list.
+		if (maxtime)
+		{
+			time_t mintime = ServerInstance->Time() - maxtime;
+			while (!lines.empty() && lines.front().ts < mintime)
+				lines.pop_front();
+		}
+		return lines.size();
+	}
 };
 
 class HistoryMode : public ParamMode<HistoryMode, SimpleExtItem<HistoryList> >
@@ -108,6 +120,7 @@ class HistoryMode : public ParamMode<HistoryMode, SimpleExtItem<HistoryList> >
 
 			history->maxlen = len;
 			history->maxtime = time;
+			history->Prune();
 		}
 		else
 		{
@@ -165,7 +178,7 @@ class ModuleChanHistory
 		}
 	}
 
-	void SendHistory(LocalUser* user, Channel* channel, HistoryList* list, time_t mintime)
+	void SendHistory(LocalUser* user, Channel* channel, HistoryList* list)
 	{
 		if (batchmanager)
 		{
@@ -173,19 +186,16 @@ class ModuleChanHistory
 			batch.GetBatchStartMessage().PushParamRef(channel->name);
 		}
 
-		for(std::deque<HistoryItem>::iterator i = list->lines.begin(); i != list->lines.end(); ++i)
+		for (std::deque<HistoryItem>::iterator i = list->lines.begin(); i != list->lines.end(); ++i)
 		{
 			HistoryItem& item = *i;
-			if (item.ts >= mintime)
-			{
-				ClientProtocol::Messages::Privmsg msg(ClientProtocol::Messages::Privmsg::nocopy, item.sourcemask, channel, item.text, item.type);
-				for (HistoryTagMap::iterator iter = item.tags.begin(); iter != item.tags.end(); ++iter)
-					AddTag(msg, iter->first, iter->second);
-				if (servertimemanager)
-					servertimemanager->Set(msg, item.ts);
-				batch.AddToBatch(msg);
-				user->Send(ServerInstance->GetRFCEvents().privmsg, msg);
-			}
+			ClientProtocol::Messages::Privmsg msg(ClientProtocol::Messages::Privmsg::nocopy, item.sourcemask, channel, item.text, item.type);
+			for (HistoryTagMap::iterator iter = item.tags.begin(); iter != item.tags.end(); ++iter)
+				AddTag(msg, iter->first, iter->second);
+			if (servertimemanager)
+				servertimemanager->Set(msg, item.ts);
+			batch.AddToBatch(msg);
+			user->Send(ServerInstance->GetRFCEvents().privmsg, msg);
 		}
 
 		if (batchmanager)
@@ -250,7 +260,7 @@ class ModuleChanHistory
 			return;
 
 		HistoryList* list = historymode.ext.get(memb->chan);
-		if (!list)
+		if (!list || !list->Prune())
 			return;
 
 		if ((prefixmsg) && (!batchcap.get(localuser)))
@@ -261,11 +271,7 @@ class ModuleChanHistory
 			memb->WriteNotice(message);
 		}
 
-		time_t mintime = 0;
-		if (list->maxtime)
-			mintime = ServerInstance->Time() - list->maxtime;
-
-		SendHistory(localuser, memb->chan, list, mintime);
+		SendHistory(localuser, memb->chan, list);
 	}
 
 	Version GetVersion() CXX11_OVERRIDE
diff --git a/src/modules/m_check.cpp b/src/modules/m_check.cpp
index f19f610e9..714f0bddd 100644
--- a/src/modules/m_check.cpp
+++ b/src/modules/m_check.cpp
@@ -171,7 +171,6 @@ class CommandCheck : public Command
 
 		User *targuser;
 		Channel *targchan;
-		std::string chliststr;
 
 		targuser = ServerInstance->FindNick(parameters[0]);
 		targchan = ServerInstance->FindChan(parameters[0]);
@@ -242,13 +241,7 @@ class CommandCheck : public Command
 			for (User::ChanList::iterator i = targuser->chans.begin(); i != targuser->chans.end(); i++)
 			{
 				Membership* memb = *i;
-				Channel* c = memb->chan;
-				char prefix = memb->GetPrefixChar();
-				if (prefix)
-					chliststr.push_back(prefix);
-				chliststr.append(c->name);
-				chanlist.Add(chliststr);
-				chliststr.clear();
+				chanlist.Add(memb->GetAllPrefixChars() + memb->chan->name);
 			}
 
 			chanlist.Flush();
diff --git a/src/modules/m_deaf.cpp b/src/modules/m_deaf.cpp
index 80e50e07e..8250e6d31 100644
--- a/src/modules/m_deaf.cpp
+++ b/src/modules/m_deaf.cpp
@@ -26,6 +26,7 @@
 
 
 #include "inspircd.h"
+#include "modules/ctctags.h"
 
 // User mode +d - filter out channel messages and channel notices
 class DeafMode : public ModeHandler
@@ -69,17 +70,65 @@ class PrivDeafMode : public ModeHandler
 	}
 };
 
-class ModuleDeaf : public Module
+class ModuleDeaf
+	: public Module
+	, public CTCTags::EventListener
 {
+ private:
 	DeafMode deafmode;
 	PrivDeafMode privdeafmode;
 	std::string deaf_bypasschars;
 	std::string deaf_bypasschars_uline;
 	bool privdeafuline;
 
+	ModResult HandleChannel(User* source, Channel* target, CUList& exemptions, bool is_bypasschar, bool is_bypasschar_uline)
+	{
+		const Channel::MemberMap& ulist = target->GetUsers();
+		for (Channel::MemberMap::const_iterator i = ulist.begin(); i != ulist.end(); ++i)
+		{
+			User* member = i->first;
+
+			// Allow if the user doesn't have the mode set.
+			if (!member->IsModeSet(deafmode))
+				continue;
+
+			// Allow if the message begins with a uline char and the
+			// user is on a ulined server.
+			if (is_bypasschar_uline && member->server->IsULine())
+				continue;
+
+			// Allow if the prefix begins with a normal char and the
+			// user is not on a ulined server.
+			if (is_bypasschar && !member->server->IsULine())
+				continue;
+
+			exemptions.insert(member);
+		}
+
+		return MOD_RES_PASSTHRU;
+	}
+
+	ModResult HandleUser(User* source, User* target)
+	{
+		// Allow if the mode is not set.
+		if (!target->IsModeSet(privdeafmode))
+			return MOD_RES_PASSTHRU;
+
+		// Reject if the source is ulined and privdeafuline is disaled.
+		if (!privdeafuline && source->server->IsULine())
+			return MOD_RES_DENY;
+
+		// Reject if the source doesn't have the right priv.
+		if (!source->HasPrivPermission("users/ignore-privdeaf"))
+			return MOD_RES_DENY;
+
+		return MOD_RES_ALLOW;
+	}
+
  public:
 	ModuleDeaf()
-		: deafmode(this)
+		: CTCTags::EventListener(this)
+		, deafmode(this)
 		, privdeafmode(this)
 	{
 	}
@@ -92,58 +141,46 @@ class ModuleDeaf : public Module
 		privdeafuline = tag->getBool("privdeafuline", true);
 	}
 
+	ModResult OnUserPreTagMessage(User* user, const MessageTarget& target, CTCTags::TagMessageDetails& details) CXX11_OVERRIDE
+	{
+		switch (target.type)
+		{
+			case MessageTarget::TYPE_CHANNEL:
+				return HandleChannel(user, target.Get<Channel>(), details.exemptions, false, false);
+
+			case MessageTarget::TYPE_USER:
+				return HandleUser(user, target.Get<User>());
+
+			case MessageTarget::TYPE_SERVER:
+				break;
+		}
+
+		return MOD_RES_PASSTHRU;
+	}
+
 	ModResult OnUserPreMessage(User* user, const MessageTarget& target, MessageDetails& details) CXX11_OVERRIDE
 	{
 		switch (target.type)
 		{
 			case MessageTarget::TYPE_CHANNEL:
 			{
-				Channel* chan = target.Get<Channel>();
-				bool is_bypasschar = (deaf_bypasschars.find(details.text[0]) != std::string::npos);
-				bool is_bypasschar_uline = (deaf_bypasschars_uline.find(details.text[0]) != std::string::npos);
-
 				// If we have no bypasschars_uline in config, and this is a bypasschar (regular)
 				// Then it is obviously going to get through +d, no exemption list required
+				bool is_bypasschar = (deaf_bypasschars.find(details.text[0]) != std::string::npos);
 				if (deaf_bypasschars_uline.empty() && is_bypasschar)
 					return MOD_RES_PASSTHRU;
+
 				// If it matches both bypasschar and bypasschar_uline, it will get through.
+				bool is_bypasschar_uline = (deaf_bypasschars_uline.find(details.text[0]) != std::string::npos);
 				if (is_bypasschar && is_bypasschar_uline)
 					return MOD_RES_PASSTHRU;
 
-				const Channel::MemberMap& ulist = chan->GetUsers();
-				for (Channel::MemberMap::const_iterator i = ulist.begin(); i != ulist.end(); ++i)
-				{
-					// not +d
-					if (!i->first->IsModeSet(deafmode))
-						continue;
-
-					bool is_a_uline = i->first->server->IsULine();
-					// matched a U-line only bypass
-					if (is_bypasschar_uline && is_a_uline)
-						continue;
-					// matched a regular bypass
-					if (is_bypasschar && !is_a_uline)
-						continue;
-
-					// don't deliver message!
-					details.exemptions.insert(i->first);
-				}
-				break;
+				return HandleChannel(user, target.Get<Channel>(), details.exemptions, is_bypasschar, is_bypasschar_uline);
 			}
-			case MessageTarget::TYPE_USER:
-			{
-				User* targ = target.Get<User>();
-				if (!targ->IsModeSet(privdeafmode))
-					return MOD_RES_PASSTHRU;
-
-				if (!privdeafuline && user->server->IsULine())
-					return MOD_RES_DENY;
 
-				if (!user->HasPrivPermission("users/ignore-privdeaf"))
-					return MOD_RES_DENY;
+			case MessageTarget::TYPE_USER:
+				return HandleUser(user, target.Get<User>());
 
-				break;
-			}
 			case MessageTarget::TYPE_SERVER:
 				break;
 		}
diff --git a/src/modules/m_dnsbl.cpp b/src/modules/m_dnsbl.cpp
index 57a780ff2..dc43dda3f 100644
--- a/src/modules/m_dnsbl.cpp
+++ b/src/modules/m_dnsbl.cpp
@@ -42,12 +42,14 @@ class DNSBLConfEntry : public refcountbase
 		EnumType type;
 		unsigned long duration;
 		unsigned int bitmask;
+		unsigned int timeout;
 		unsigned char records[256];
 		unsigned long stats_hits, stats_misses, stats_errors;
 		DNSBLConfEntry()
 			: type(A_BITMASK)
 			, duration(86400)
 			, bitmask(0)
+			, timeout(0)
 			, stats_hits(0)
 			, stats_misses(0)
 			, stats_errors(0)
@@ -69,7 +71,7 @@ class DNSBLResolver : public DNS::Request
 
  public:
 	DNSBLResolver(DNS::Manager *mgr, Module *me, LocalStringExt& match, LocalIntExt& ctr, const std::string &hostname, LocalUser* u, reference<DNSBLConfEntry> conf)
-		: DNS::Request(mgr, me, hostname, DNS::QUERY_A, true)
+		: DNS::Request(mgr, me, hostname, DNS::QUERY_A, true, conf->timeout)
 		, theirsa(u->client_sa)
 		, theiruid(u->uuid)
 		, nameExt(match)
@@ -343,6 +345,7 @@ class ModuleDNSBL : public Module, public Stats::EventListener
 			e->host = tag->getString("host");
 			e->reason = tag->getString("reason", "Your IP has been blacklisted.", 1);
 			e->domain = tag->getString("domain");
+			e->timeout = tag->getDuration("timeout", 0);
 
 			if (stdalgo::string::equalsci(tag->getString("type"), "bitmask"))
 			{
diff --git a/src/modules/m_filter.cpp b/src/modules/m_filter.cpp
index 566b46912..aea68e4cf 100644
--- a/src/modules/m_filter.cpp
+++ b/src/modules/m_filter.cpp
@@ -962,7 +962,9 @@ bool ModuleFilter::Tick(time_t)
 			return true;
 		}
 
-		stream << "# This file is automatically generated by the filter module. Any changes will be overwritten." << std::endl
+		stream
+			<< "# This file was automatically generated by the " << INSPIRCD_VERSION << " filter module on " << InspIRCd::TimeString(ServerInstance->Time()) << "." << std::endl
+			<< "# Any changes to this file will be automatically overwritten." << std::endl
 			<< "# If you want to convert this to a normal config file you *MUST* remove the generated=\"yes\" keys!" << std::endl
 			<< std::endl
 			<< "<config format=\"xml\">" << std::endl;
diff --git a/src/modules/m_hideoper.cpp b/src/modules/m_hideoper.cpp
index 3b64c23c4..64872850a 100644
--- a/src/modules/m_hideoper.cpp
+++ b/src/modules/m_hideoper.cpp
@@ -160,8 +160,9 @@ class ModuleHideOper
 			if (!oper->server->IsULine() && (stats.GetSource()->IsOper() || !oper->IsModeSet(hm)))
 			{
 				LocalUser* lu = IS_LOCAL(oper);
-				stats.AddRow(249, oper->nick + " (" + oper->ident + "@" + oper->GetDisplayedHost() + ") Idle: " +
-						(lu ? ConvToStr(ServerInstance->Time() - lu->idle_lastmsg) + " secs" : "unavailable"));
+				const std::string idle = lu ? InspIRCd::DurationString(ServerInstance->Time() - lu->idle_lastmsg) : "unavailable";
+				stats.AddRow(249, InspIRCd::Format("%s (%s@%s) Idle: %s", oper->nick.c_str(),
+					oper->ident.c_str(), oper->GetDisplayedHost().c_str(), idle.c_str()));
 				count++;
 			}
 		}
diff --git a/src/modules/m_httpd_acl.cpp b/src/modules/m_httpd_acl.cpp
index 533e3c578..197bf589e 100644
--- a/src/modules/m_httpd_acl.cpp
+++ b/src/modules/m_httpd_acl.cpp
@@ -200,20 +200,30 @@ class ModuleHTTPAccessList : public Module, public HTTPACLEventListener
 										return true;
 									}
 									else
+									{
 										/* Invalid password */
+										ServerInstance->Logs->Log(MODNAME, LOG_DEBUG, "HTTP authorization: password and username do not match");
 										BlockAccess(http, 401, "WWW-Authenticate", "Basic realm=\"Restricted Object\"");
+									}
 								}
 								else
+								{
 									/* Malformed user:pass pair */
+									ServerInstance->Logs->Log(MODNAME, LOG_DEBUG, "HTTP authorization: password and username malformed");
 									BlockAccess(http, 401, "WWW-Authenticate", "Basic realm=\"Restricted Object\"");
+								}
 							}
 							else
+							{
 								/* Unsupported authentication type */
+								ServerInstance->Logs->Log(MODNAME, LOG_DEBUG, "HTTP authorization: unsupported auth type: %s", authtype.c_str());
 								BlockAccess(http, 401, "WWW-Authenticate", "Basic realm=\"Restricted Object\"");
+							}
 						}
 						else
 						{
 							/* No password given at all, access denied */
+							ServerInstance->Logs->Log(MODNAME, LOG_DEBUG, "HTTP authorization: password and username not sent");
 							BlockAccess(http, 401, "WWW-Authenticate", "Basic realm=\"Restricted Object\"");
 						}
 						return false;
diff --git a/src/modules/m_ldapauth.cpp b/src/modules/m_ldapauth.cpp
index 8fc0ca0b0..4885bc0e5 100644
--- a/src/modules/m_ldapauth.cpp
+++ b/src/modules/m_ldapauth.cpp
@@ -331,7 +331,7 @@ public:
 		vhost			= tag->getString("host");
 		// Set to true if failed connects should be reported to operators
 		verbose			= tag->getBool("verbose");
-		useusername		= tag->getBool("userfield");
+		useusername		= tag->getBool("useusername", tag->getBool("userfield"));
 
 		LDAP.SetProvider("LDAP/" + tag->getString("dbid"));
 
diff --git a/src/modules/m_permchannels.cpp b/src/modules/m_permchannels.cpp
index fdc75ec34..0651f5cdc 100644
--- a/src/modules/m_permchannels.cpp
+++ b/src/modules/m_permchannels.cpp
@@ -77,7 +77,10 @@ static bool WriteDatabase(PermChannel& permchanmode, Module* mod, bool save_list
 		return false;
 	}
 
-	stream << "# This file is automatically generated by m_permchannels. Any changes will be overwritten." << std::endl
+	stream
+		<< "# This file was automatically generated by the " << INSPIRCD_VERSION << " permchannels module on " << InspIRCd::TimeString(ServerInstance->Time()) << "." << std::endl
+		<< "# Any changes to this file will be automatically overwritten." << std::endl
+		<< std::endl
 		<< "<config format=\"xml\">" << std::endl;
 
 	const chan_hash& chans = ServerInstance->GetChans();
diff --git a/src/modules/m_rline.cpp b/src/modules/m_rline.cpp
index 7ef766b7d..f4c675919 100644
--- a/src/modules/m_rline.cpp
+++ b/src/modules/m_rline.cpp
@@ -37,15 +37,6 @@ static bool added_zline = false;
 class RLine : public XLine
 {
  public:
-
-	/** Create a R-line.
-	 * @param s_time The set time
-	 * @param d The duration of the xline
-	 * @param src The sender of the xline
-	 * @param re The reason of the xline
-	 * @param regex Pattern to match with
-	 * @
-	 */
 	RLine(time_t s_time, unsigned long d, const std::string& src, const std::string& re, const std::string& regexs, dynamic_reference<RegexFactory>& rxfactory)
 		: XLine(s_time, d, src, re, "R")
 		, matchtext(regexs)
@@ -56,8 +47,6 @@ class RLine : public XLine
 		regex = rxfactory->Create(regexs);
 	}
 
-	/** Destructor
-	 */
 	~RLine()
 	{
 		delete regex;
diff --git a/src/users.cpp b/src/users.cpp
index 7029accc0..2513a7830 100644
--- a/src/users.cpp
+++ b/src/users.cpp
@@ -1159,9 +1159,16 @@ void LocalUser::SetClass(const std::string &explicit_name)
 				continue;
 			}
 
-			/* check if host matches.. */
-			if (!InspIRCd::MatchCIDR(this->GetIPString(), c->GetHost(), NULL) &&
-				!InspIRCd::MatchCIDR(this->GetRealHost(), c->GetHost(), NULL))
+			bool hostmatches = false;
+			for (std::vector<std::string>::const_iterator host = c->GetHosts().begin(); host != c->GetHosts().end(); ++host)
+			{
+				if (InspIRCd::MatchCIDR(this->GetIPString(), *host) || InspIRCd::MatchCIDR(this->GetRealHost(), *host))
+				{
+					hostmatches = true;
+					break;
+				}
+			}
+			if (!hostmatches)
 			{
 				ServerInstance->Logs->Log("CONNECTCLASS", LOG_DEBUG, "The %s connect class is not suitable as neither the host (%s) nor the IP (%s) matches %s",
 					c->GetName().c_str(), this->GetRealHost().c_str(), this->GetIPString().c_str(), c->GetHost().c_str());
@@ -1266,6 +1273,9 @@ ConnectClass::ConnectClass(ConfigTag* tag, char t, const std::string& mask)
 	, limit(0)
 	, resolvehostnames(true)
 {
+	irc::spacesepstream hoststream(host);
+	for (std::string hostentry; hoststream.GetToken(hostentry); )
+		hosts.push_back(hostentry);
 }
 
 ConnectClass::ConnectClass(ConfigTag* tag, char t, const std::string& mask, const ConnectClass& parent)
@@ -1274,6 +1284,10 @@ ConnectClass::ConnectClass(ConfigTag* tag, char t, const std::string& mask, cons
 	name = "unnamed";
 	type = t;
 	host = mask;
+	hosts.clear();
+	irc::spacesepstream hoststream(host);
+	for (std::string hostentry; hoststream.GetToken(hostentry); )
+		hosts.push_back(hostentry);
 
 	// Connect classes can inherit from each other but this is problematic for modules which can't use
 	// ConnectClass::Update so we build a hybrid tag containing all of the values set on this class as
@@ -1309,6 +1323,7 @@ void ConnectClass::Update(const ConnectClass* src)
 	name = src->name;
 	registration_timeout = src->registration_timeout;
 	host = src->host;
+	hosts = src->hosts;
 	pingtime = src->pingtime;
 	softsendqmax = src->softsendqmax;
 	hardsendqmax = src->hardsendqmax;
diff --git a/tools/testssl b/tools/testssl
index 52a152144..1c80ec0eb 100755
--- a/tools/testssl
+++ b/tools/testssl
@@ -105,14 +105,14 @@ It appears that the server endpoint is using plaintext! Make sure that:
     - ssl_mbedtls
 
   * If you have specified one or more <sslprofile> tags then the value of
-    <bind:ssl> is the same as an <sslprofile:name> field. Otherwise, it should
-    be set to "gnutls" for the ssl_gnutls module, "openssl" for the ssl_openssl
-    module, or "mbedtls" for the ssl_mbedtls module.
-
-  * If you have specified the name of an <sslprofile> in <bind:ssl> then the
-    value of <sslprofile:provider> is set to "gnutls" if using the ssl_gnutls
-    module, "openssl" if using the ssl_openssl module, or "mbedtls" if using
-    the ssl_mbedtls module.
+    <bind:sslprofile> is the same as an <sslprofile:name> field. Otherwise, it
+    should be set to "gnutls" for the ssl_gnutls module, "openssl" for the
+    ssl_openssl module, or "mbedtls" for the ssl_mbedtls module.
+
+  * If you have specified the name of an <sslprofile> in <bind:sslprofile> then
+    the value of <sslprofile:provider> is set to "gnutls" if using the
+    ssl_gnutls module, "openssl" if using the ssl_openssl module, or "mbedtls"
+    if using the ssl_mbedtls module.
 
   * If you have your SSL configuration in a file other than inspircd.conf then
     that file is included by inspircd.conf.
